.TH "ReuseDistance" 3 "17 Oct 2012" "Version 0.01" "ReuseDistance" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ReuseDistance \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ReuseDistance.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBReuseDistance\fP (uint64_t w, uint64_t b)"
.br
.ti -1c
.RI "\fBReuseDistance\fP (uint64_t w)"
.br
.ti -1c
.RI "\fB~ReuseDistance\fP ()"
.br
.ti -1c
.RI "void \fBPrint\fP (std::ostream &f)"
.br
.ti -1c
.RI "void \fBPrint\fP ()"
.br
.ti -1c
.RI "void \fBProcess\fP (\fBReuseEntry\fP &addr)"
.br
.ti -1c
.RI "void \fBProcess\fP (\fBReuseEntry\fP *addrs, uint64_t count)"
.br
.ti -1c
.RI "void \fBProcess\fP (std::vector< \fBReuseEntry\fP > rs)"
.br
.ti -1c
.RI "void \fBProcess\fP (std::vector< \fBReuseEntry\fP * > addrs)"
.br
.ti -1c
.RI "uint64_t \fBGetDistance\fP (\fBReuseEntry\fP &addr)"
.br
.ti -1c
.RI "\fBReuseStats\fP * \fBGetStats\fP (uint64_t id)"
.br
.ti -1c
.RI "void \fBGetIndices\fP (std::vector< uint64_t > &ids)"
.br
.ti -1c
.RI "void \fBGetActiveAddresses\fP (std::vector< uint64_t > &addrs)"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const uint64_t \fBDefaultBinIndividual\fP = 32"
.br
.ti -1c
.RI "static const uint64_t \fBInfinity\fP = 0"
.br
.in -1c
.SH "Detailed Description"
.PP 
Tracks reuse distances for a memory address stream. Keep track of the addresses within a specific window of history, whose size can be finite or infinite. For basic usage, see the documentation for the constructors, the Process methods and the Print methods. Also see the simple test file test/test.cpp included in the source package. 
.PP
Definition at line 171 of file ReuseDistance.hpp.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ReuseDistance::ReuseDistance (uint64_t w, uint64_t b)"Contructs a \fBReuseDistance\fP object.
.PP
\fBParameters:\fP
.RS 4
\fIw\fP The maximum window size, or alternatively the maximum possible reuse distance that this tool will find. No window/distance limit is imposed if \fBReuseDistance::Infinity\fP is used, though you could easily run of of memory. 
.br
\fIb\fP All distances not greater than b will be tracked individually. All distances are tracked individually if b == \fBReuseDistance::Infinity\fP. Beyond individual tracking, distances are tracked in bins whose boundaries are the powers of two greater than b (and not exeeding w, of course). 
.RE
.PP

.PP
Definition at line 49 of file ReuseDistance.cpp.
.SS "ReuseDistance::ReuseDistance (uint64_t w)"Contructs a \fBReuseDistance\fP object. Equivalent to calling the other constructor with b == \fBReuseDistance::DefaultBinIndividual\fP
.PP
\fBParameters:\fP
.RS 4
\fIw\fP The maximum window size, or alternatively the maximum possible reuse distance that this tool will find. No window/distance limit if \fBReuseDistance::Infinity\fP is used, though you could easily run out of memory. 
.RE
.PP

.PP
Definition at line 53 of file ReuseDistance.cpp.
.SS "ReuseDistance::~ReuseDistance ()"Destroys a \fBReuseDistance\fP object. 
.PP
Definition at line 57 of file ReuseDistance.cpp.
.SH "Member Function Documentation"
.PP 
.SS "void ReuseDistance::GetActiveAddresses (std::vector< uint64_t > & addrs)"Get a std::vector containing all of the addresses currently in this \fBReuseDistance\fP object's active window.
.PP
\fBParameters:\fP
.RS 4
\fIaddrs\fP A std::vector which will contain the addresses. It is an error to pass this vector non-empty (that is addrs.size() == 0 is enforced at runtime).
.RE
.PP
\fBReturns:\fP
.RS 4
none 
.RE
.PP

.PP
Definition at line 79 of file ReuseDistance.cpp.
.SS "uint64_t ReuseDistance::GetDistance (\fBReuseEntry\fP & addr)"Get a reuse distance for a \fBReuseEntry\fP without updating any internal state.
.PP
\fBParameters:\fP
.RS 4
\fIaddr\fP The memory address to analyze.
.RE
.PP
\fBReturns:\fP
.RS 4
The reuse distance for the memory address given by addr. 
.RE
.PP

.PP
Definition at line 135 of file ReuseDistance.cpp.
.SS "void ReuseDistance::GetIndices (std::vector< uint64_t > & ids)"Get a std::vector containing all of the unique indices processed by this \fBReuseDistance\fP object.
.PP
\fBParameters:\fP
.RS 4
\fIids\fP A std::vector which will contain the ids. It is an error to pass this vector non-empty (that is addrs.size() == 0 is enforced at runtime).
.RE
.PP
\fBReturns:\fP
.RS 4
none 
.RE
.PP

.PP
Definition at line 71 of file ReuseDistance.cpp.
.SS "\fBReuseStats\fP * ReuseDistance::GetStats (uint64_t id)"Get the \fBReuseStats\fP object associated with some unique id.
.PP
\fBParameters:\fP
.RS 4
\fIid\fP The unique id.
.RE
.PP
\fBReturns:\fP
.RS 4
The \fBReuseStats\fP object associated with parameter id, or NULL if no \fBReuseStats\fP is associate with id. 
.RE
.PP

.PP
Definition at line 241 of file ReuseDistance.cpp.
.SS "void ReuseDistance::Print ()"Print statistics for this \fBReuseDistance\fP to std::cout. See the other version of \fBReuseDistance::Print\fP for information about output format.
.PP
\fBReturns:\fP
.RS 4
none 
.RE
.PP

.PP
Definition at line 89 of file ReuseDistance.cpp.
.SS "void ReuseDistance::Print (std::ostream & f)"Print statistics for this \fBReuseDistance\fP to an output stream. The first line of the output is five tokens which are [1] the string literal REUSESTATS, [2] the unique id, [3] the window size (0 == unlimited) [4] the total number of accesses for that unique id and [5] the number of accesses from that id which were not found within the active address window either because they were evicted or because of cold misses. Each additional line of output contains three tokens, which give [1] the minimum of a reuse distance range (inclusive), [2] the maximum of a reuse distance range (inclusive) and [2] the number of times a reusedistance in that range was observed.
.PP
\fBParameters:\fP
.RS 4
\fIf\fP The output stream to print results to.
.RE
.PP
\fBReturns:\fP
.RS 4
none 
.RE
.PP

.SS "void ReuseDistance::Process (std::vector< \fBReuseEntry\fP * > addrs)"Process multiple memory addresses. Equivalent to calling Process on each element of the input vector.
.PP
\fBParameters:\fP
.RS 4
\fIaddrs\fP A std::vector of memory addresses to process.
.RE
.PP
\fBReturns:\fP
.RS 4
none 
.RE
.PP

.SS "void ReuseDistance::Process (std::vector< \fBReuseEntry\fP > rs)"Process multiple memory addresses. Equivalent to calling Process on each element of the input vector.
.PP
\fBParameters:\fP
.RS 4
\fIaddrs\fP A std::vector of memory addresses to process.
.RE
.PP
\fBReturns:\fP
.RS 4
none 
.RE
.PP

.SS "void ReuseDistance::Process (\fBReuseEntry\fP * addrs, uint64_t count)"Process multiple memory addresses. Equivalent to calling Process on each element of the input array.
.PP
\fBParameters:\fP
.RS 4
\fIaddrs\fP An array of structures describing memory addresses to process. 
.br
\fIcount\fP The number of elements in addrs.
.RE
.PP
\fBReturns:\fP
.RS 4
none 
.RE
.PP

.PP
Definition at line 115 of file ReuseDistance.cpp.
.SS "void ReuseDistance::Process (\fBReuseEntry\fP & addr)"Process a single memory address.
.PP
\fBParameters:\fP
.RS 4
\fIaddr\fP The structure describing the memory address to process.
.RE
.PP
\fBReturns:\fP
.RS 4
none 
.RE
.PP

.PP
Definition at line 176 of file ReuseDistance.cpp.
.SH "Member Data Documentation"
.PP 
.SS "const uint64_t \fBReuseDistance::DefaultBinIndividual\fP = 32\fC [static]\fP"
.PP
Definition at line 197 of file ReuseDistance.hpp.
.SS "const uint64_t \fBReuseDistance::Infinity\fP = 0\fC [static]\fP"
.PP
Definition at line 198 of file ReuseDistance.hpp.

.SH "Author"
.PP 
Generated automatically by Doxygen for ReuseDistance from the source code.
